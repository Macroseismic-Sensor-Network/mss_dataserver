#!/usr/bin/env python3
# -*- coding: utf-8 -*-
##############################################################################
 # LICENSE
 #
 # This file is part of mss_dataserver.
 # 
 # If you use mss_dataserver in any program or publication, please inform and
 # acknowledge its authors.
 # 
 # mss_dataserver is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 # 
 # mss_dataserver is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 # 
 # You should have received a copy of the GNU General Public License
 # along with mss_dataserver. If not, see <http://www.gnu.org/licenses/>.
 #
 # Copyright 2019 Stefan Mertl
##############################################################################


# Websocket example to test the connection with javascript using vue.js.

import argparse
import configparser
import copy
import datetime
import functools
import json
import logging
import os
import random
import threading

import asyncio
import concurrent.futures
import websockets
import obspy
import sqlalchemy
import sqlalchemy.ext.declarative
import sqlalchemy.orm

import mss_dataserver.core.project
import mss_dataserver.geometry.inventory_parser as inventory_parser
import mss_dataserver.monitorclient.monitorclient as monitorclient


logger = logging.getLogger('mss_dataserver')
logger.setLevel(logging.DEBUG)
logger.addHandler(logging.StreamHandler())


# The clients connected to the server.
clients_lock = threading.Lock()
clients = set()

clients_keydata_lock = threading.Lock()
clients_keydata = set()

class Producer(object):
    def __init__(self):
        self.data = 0

    async def rand_value(self):
        await asyncio.sleep(1)
        self.data += 1
        return self.data

#async def serve_pgv(websocket, path, producer):
#    while True:
#        product = await producer.rand_value()
#        data = {}
#        data['time'] = datetime.datetime.utcnow().isoformat() + 'Z'
#        data['pgv'] = product
#        msg = json.dumps(data)
#        await websocket.send(msg)


msg_class = {}
msg_class['control'] = 'control'
msg_class['soh'] = 'soh'
msg_class['data'] = 'data'

msg_control_id = {}
msg_control_id['mode'] = 'mode'

msg_soh_id = {}
msg_soh_id['connection'] = 'connection'
msg_soh_id['server_state'] = 'server_state'

msg_data_id = {}
msg_data_id['pgv'] = 'pgv'
msg_data_id['pgv_archive'] = 'pgv_archive'
msg_data_id['detection_result'] = 'detection_result'
msg_data_id['event_data'] = 'event_data'
msg_data_id['event_archive'] = 'event_archive'
msg_data_id['event_warning'] = 'event_warning'
msg_data_id['keydata'] = 'keydata'


async def register_pgv_client(websocket, sl_client):
    ''' Register a connected websocket client.
    '''
    # Prepare the welcome message.
    msg = {}
    msg['class'] = msg_class['soh']
    msg['id'] = msg_soh_id['connection']

    payload = {}
    payload['state'] = 'registered'
    payload['server_id'] = 'mss data server'
    msg['payload'] = payload

    try:
        logging.info("Registering the client.")
        # Send the welcome message.
        msg = json.dumps(msg, allow_nan = False)
        await websocket.send(msg)

        # Prepare the archived PGV data message.
        msg = {}
        msg['class'] = msg_class['data']
        msg['id'] = msg_data_id['pgv_archive']

        payload = sl_client.get_pgv_archive()
        msg['payload'] = payload

        logging.info("Sending pgv archive.")
        # Send the archived PGV data.
        msg = json.dumps(msg, allow_nan = False)
        await websocket.send(msg)

        # Send the current event if it exists.
        payload = sl_client.get_current_event()

        if payload:
            msg = {}
            msg['class'] = msg_class['data']
            msg['id'] = msg_data_id['event_data']
            msg['payload'] = payload

            logging.info("Sending the current event.")
            # Send the archived PGV data.
            msg = json.dumps(msg, allow_nan = False)
            await websocket.send(msg)

        # Send the event archive if it exists.
        payload = sl_client.get_event_archive()

        if payload:
            msg = {}
            msg['class'] = msg_class['data']
            msg['id'] = msg_data_id['event_archive']
            msg['payload'] = payload

            logging.info("Sending the event archive.")
            # Send the archived PGV data.
            msg = json.dumps(msg, allow_nan = False)
            await websocket.send(msg)

        # The client has been registered and the archive has been sent,
        # now add the websocket to the known clients.
        with clients_lock:
            clients.add(websocket)
        logging.info("Client registered.")
    except Exception as e:
        logging.exception("Error registering the client.")


async def register_keydata_client(websocket, sl_client):
    ''' Register a connected websocket client for sending keydata messages.
    '''
    # Prepare the welcome message.
    msg = {}
    msg['class'] = msg_class['soh']
    msg['id'] = msg_soh_id['connection']

    payload = {}
    payload['state'] = 'registered'
    payload['server_id'] = 'mss data server'
    msg['payload'] = payload

    try:
        logging.info("Registering the client.")
        # Send the welcome message.
        msg = json.dumps(msg, allow_nan = False)
        await websocket.send(msg)

        # Send the initial keydata to the new client.
        payload = sl_client.get_keydata()
        if payload:
            logging.info("Sending the initial keydata.")
            msg = {}
            msg['class'] = msg_class['data']
            msg['id'] = msg_data_id['keydata']
            msg['payload'] = payload
            msg = json.dumps(msg, allow_nan = False)
            await websocket.send(msg)

        # The client has been registered and the keydata has been sent,
        # now add the websocket to the known clients.
        with clients_keydata_lock:
            clients_keydata.add(websocket)
        logging.info("Client registered.")

    except Exception as e:
        logging.exception("Error registering the client.")


async def unregister_client(websocket):
    ''' Unregister a disconnected websocket client.
    '''
    with clients_lock:
        clients.remove(websocket)


async def unregister_keydata_client(websocket):
    ''' Unregister a disconnected keydata websocket client.
    '''
    with clients_keydata_lock:
        clients_keydata.remove(websocket)


async def serve_keydata(sl_client):
    ''' Send the server keydata to all registered clients.
    '''
    try:
        while True:
            await sl_client.event_keydata_available.wait()
            payload = sl_client.get_keydata()

            msg = {}
            msg['class'] = msg_class['data']
            msg['id'] = msg_data_id['keydata']
            msg['payload'] = payload
            msg = json.dumps(msg, allow_nan = False)

            logging.info("Serving the keydata.")
            with clients_keydata_lock:
                clients_copy = copy.copy(clients_keydata)
            for cur_client in clients_copy:
                logging.info("Sending to client %s.", cur_client)
                try:
                    await cur_client.send(msg)
                except Exception as e:
                    logging.exception("Error sending to client: %s.",
                                      cur_client)
            sl_client.event_keydata_available.clear()
    except Exception as e:
        logging.exception("Error while serving the keydata.")
        #TODO: What happens with the task if an exception occured.
        # Is it automatically restarted or do I have to take care of this?


async def serve_data(sl_client):
    ''' Send the data to all registered clients.
    '''
    try:
        while True:
            await sl_client.pgv_data_available.wait()
            payload = sl_client.get_pgv_data()

            msg = {}
            msg['class'] = msg_class['data']
            msg['id'] = msg_data_id['pgv']
            msg['payload'] = payload
            msg = json.dumps(msg, allow_nan = False)

            logging.info("Serving the data.")
            with clients_lock:
                clients_copy = copy.copy(clients)
            for cur_client in clients_copy:
                logging.info("Sending to client %s.", cur_client)
                try:
                    await cur_client.send(msg)
                except Exception as e:
                    logging.exception("Error sending to client: %s.",
                                      cur_client)
            sl_client.pgv_data_available.clear()
    except Exception as e:
        logging.exception("Error while serving the data.")
        #TODO: What happens with the task if an exception occured.
        # Is it automatically restarted or do I have to take care of this?


async def serve_detection_result(sl_client):
    ''' Send the event detectionresult to all registerd clients.
    '''
    try:
        while True:
            await sl_client.event_detection_result_available.wait()
            payload = sl_client.last_detection_result

            msg = {}
            msg['class'] = msg_class['data']
            msg['id'] = msg_data_id['detection_result']
            msg['payload'] = payload
            msg = json.dumps(msg, allow_nan = False)

            logging.info("Serving the detection result.")
            with clients_lock:
                clients_copy = copy.copy(clients)
            for cur_client in clients_copy:
                logging.info("Sending to client %s.", cur_client)
                try:
                    await cur_client.send(msg)
                except Exception as e:
                    logging.exception("Error sending to client: %s.",
                                      cur_client)
            sl_client.event_detection_result_available.clear()
    except Exception as e:
        logging.exception("Error while serving the detection result.")


async def serve_event_data(sl_client):
    ''' Send the event data to all registerd clients.
    '''
    try:
        while True:
            await sl_client.event_data_available.wait()
            payload = sl_client.get_current_event()

            msg = {}
            msg['class'] = msg_class['data']
            msg['id'] = msg_data_id['event_data']
            msg['payload'] = payload
            msg = json.dumps(msg, allow_nan = False)

            logging.info("Serving the event data.")
            with clients_lock:
                clients_copy = copy.copy(clients)
            for cur_client in clients_copy:
                logging.info("Sending to client %s.", cur_client)
                try:
                    await cur_client.send(msg)
                except Exception as e:
                    logging.exception("Error sending to client: %s.",
                                      cur_client)
            sl_client.event_data_available.clear()
    except Exception as e:
        logging.exception("Error while serving the event data.")


async def serve_event_archive(sl_client):
    ''' Send the event archive to all registerd clients.
    '''
    try:
        while True:
            await sl_client.event_archive_changed.wait()
            payload = sl_client.get_event_archive()

            # TODO: Sending the archive each time an event has been added
            # doesn't make sense. All data is already at the Client. Move the
            # update of the archive completely to the server. Send the archive
            # only at first connection with the client.

            msg = {}
            msg['class'] = msg_class['data']
            msg['id'] = msg_data_id['event_archive']
            msg['payload'] = payload
            msg = json.dumps(msg, allow_nan = False)

            logging.info("Serving the event archive.")
            with clients_lock:
                clients_copy = copy.copy(clients)
            for cur_client in clients_copy:
                logging.info("Sending to client %s.", cur_client)
                try:
                    await cur_client.send(msg)
                except Exception as e:
                    logging.exception("Error sending to client: %s.",
                                      cur_client)
            sl_client.event_archive_changed.clear()
    except Exception as e:
        logging.exception("Error while serving the event archive.")


async def serve_event_warning(sl_client):
    ''' Send the event warning to all registerd clients.
    '''
    try:
        while True:
            await sl_client.event_warning_available.wait()
            payload = sl_client.get_event_warning()

            msg = {}
            msg['class'] = msg_class['data']
            msg['id'] = msg_data_id['event_warning']
            msg['payload'] = payload
            msg = json.dumps(msg, allow_nan = False)

            logging.info("Serving the event warning.")
            with clients_lock:
                clients_copy = copy.copy(clients)
            for cur_client in clients_copy:
                logging.info("Sending to client %s.", cur_client)
                try:
                    await cur_client.send(msg)
                except Exception as e:
                    logging.exception("Error sending to client: %s.",
                                      cur_client)
            sl_client.event_warning_available.clear()
    except Exception as e:
        logging.exception("Error while serving the event warning.")


async def serve_pgv(websocket, path, sl_client):
    mode = None
    try:
        async for msg in websocket:
            msg = json.loads(msg)
            logging.info("Message: %s.", msg)
            if msg['class'] == 'control':
                if msg['id'] == 'mode':
                    if msg['payload'] == 'pgv':
                        await register_pgv_client(websocket = websocket,
                                                  sl_client = sl_client)
                        mode = 'pgv'
                    elif msg['payload'] == 'keydata':
                        await register_keydata_client(websocket = websocket,
                                                  sl_client = sl_client)
                        mode = 'keydata'
                else:
                    logging.warning('Unexpected message id.', msg['id'])
                    return
            else:
                logging.warning('Unexpected control message.', msg)
                return
    except Exception as e:
        logging.warning("Lost connection to client: %s.", websocket)
    finally:
        logging.info('Unregistering the client %s.', websocket)
        if mode == 'pgv':
            await unregister_client(websocket)
            with clients_lock:
                logging.info('The registered clients are now: %s.', clients)
        elif mode == 'keydata':
            await unregister_keydata_client(websocket)
            with clients_keydata_lock:
                logging.info('The registered keydata clients are now: %s.',
                             clients_keydata)


def load_configuration(filename):
    ''' Load the configuration from a file.
    '''
    parser = configparser.ConfigParser()
    parser.read(filename)

    config = {}
    config['websocket'] = {}
    config['websocket']['host'] = parser.get('websocket', 'host').strip()
    config['websocket']['port'] = int(parser.get('websocket', 'port'))
    config['seedlink'] = {}
    config['seedlink']['host'] = parser.get('seedlink', 'host').strip()
    config['seedlink']['port'] = int(parser.get('seedlink', 'port'))
    config['output'] = {}
    config['output']['data_dir'] = parser.get('output', 'data_dir').strip()
    config['log'] = {}
    config['log']['loglevel'] = parser.get('log', 'loglevel').strip()
    config['project'] = {}
    config['project']['author_uri'] = parser.get('project', 'author_uri').strip()
    config['project']['agency_uri'] = parser.get('project', 'agency_uri').strip()
    config['project']['inventory_file'] = parser.get('project', 'inventory_file').strip()
    config['database'] = {}
    config['database']['host'] = parser.get('database', 'host').strip()
    config['database']['username'] = parser.get('database', 'username').strip()
    config['database']['password'] = parser.get('database', 'password').strip()
    config['database']['dialect'] = parser.get('database', 'dialect').strip()
    config['database']['driver'] = parser.get('database', 'driver').strip()
    config['database']['database_name'] = parser.get('database', 'database_name').strip()
    config['process'] = {}
    config['process']['stations'] = json.loads(parser.get('process', 'stations'))
    config['process']['interval'] = int(parser.get('process', 'interval'))
    config['process']['pgv_sps'] = int(parser.get('process', 'pgv_sps'))
    config['process']['trigger_threshold'] = float(parser.get('process', 'trigger_threshold'))
    config['process']['warn_threshold'] = float(parser.get('process', 'warn_threshold'))
    config['process']['valid_event_threshold'] = float(parser.get('process', 'valid_event_threshold'))
    config['process']['pgv_archive_time'] = int(parser.get('process', 'pgv_archive_time'))
    config['process']['event_archive_size'] = int(parser.get('process', 'event_archive_size'))

    return config


def start_server(project):
    ''' Start the websocket data server.
    '''
    project.connect_to_db()
    project.load_inventory()

    if project.inventory is None:
        logging.error("No inventory found in the project. Quitting.")
        return

    # Create the monitor stream attributes
    # TODO: It seems that the monitor_stream and the stream_lock could be
    # defined in the MonitorClient class.
    monitor_stream = obspy.core.Stream()
    stream_lock = threading.Lock()
    host = config['seedlink']['host']
    port = config['seedlink']['port']
    stations = config['process']['stations']
    data_dir = config['output']['data_dir']
    process_interval = config['process']['interval']
    pgv_sps = config['process']['pgv_sps']
    pgv_archive_time = config['process']['pgv_archive_time']
    trigger_thr = config['process']['trigger_threshold']
    warn_thr = config['process']['warn_threshold']
    valid_event_thr = config['process']['valid_event_threshold']
    event_archive_size = config['process']['event_archive_size']

    if len(stations) == 0:
        stations = None

    # Start the seedlink monitor client thread.
    logging.info('Creating the Seedlink client.')
    server_url = host + ':' + str(port)
    stop_event = threading.Event()
    loop = asyncio.get_event_loop()
    # TODO: Check the communication between the monitor client and the asyncio
    # loop using the event loop. Is this a good way?
    # TODO: Check the thread-safe access to the resources of the monitorclient
    # from the asyncio tasks.
    client = monitorclient.MonitorClient(project = project,
                                         asyncio_loop = loop,
                                         server_url = server_url,
                                         stations = stations,
                                         monitor_stream = monitor_stream,
                                         stream_lock = stream_lock,
                                         data_dir = data_dir,
                                         process_interval = process_interval,
                                         pgv_sps = pgv_sps,
                                         stop_event = stop_event,
                                         pgv_archive_time = pgv_archive_time,
                                         trigger_thr = trigger_thr,
                                         warn_thr = warn_thr,
                                         valid_event_thr = valid_event_thr,
                                         event_archive_size = event_archive_size)

    client_thread = threading.Thread(target = client.run)
    client_thread.start()

    #with concurrent.futures.ThreadPoolExecutor() as pool:
    #    logging.info('Starting the monitorclient thread.')
    #    result = await loop.run_in_executor(pool,
    #                                        client.run)
    #logging.info('Creating the process thread.')
    #process_thread = threading.Thread(name = 'process_timer',
    #                                  target = client.task_timer,
    #                                  args = (client.process_monitor_stream, ))
    #process_thread.start()

    prod = Producer()
    bound_handler = functools.partial(serve_pgv,
                                      sl_client = client)

    header = {'Access-Control-Allow-Origin': '*:*'}
    ws_host = config['websocket']['host']
    ws_port = config['websocket']['port']
    start_ws_server = websockets.serve(bound_handler,
                                       ws_host,
                                       ws_port,
                                       extra_headers = header)

    logging.info('Starting WS server.')
    loop.run_until_complete(start_ws_server)
    loop.create_task(client.task_timer(client.process_monitor_stream))
    #loop.create_task(client.task_timer(client.detect_event))
    loop.create_task(serve_keydata(client))
    loop.create_task(serve_data(client))
    loop.create_task(serve_detection_result(client))
    loop.create_task(serve_event_data(client))
    loop.create_task(serve_event_archive(client))
    loop.create_task(serve_event_warning(client))
    loop.run_forever()


def create_db(project):
    ''' Create or update the database.
    '''
    logging.info('Creating the database tables.')
    project.connect_to_db()

    project.create_database_tables()


def load_geometry(project):
    ''' Load the geometry inventory file into the database.
    '''
    logging.info('Updateing the database inventory with the XML inventory.')

    project.load_inventory()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description = 'MSS Websocket data server.')
    subparsers = parser.add_subparsers(title = 'sub commands',
                                       description = 'valid sub commands')
    parser.add_argument('config', help = 'The name of the configuration file.',
                        type = str)

    # The run parser.
    parser_run = subparsers.add_parser('run', help = 'Run the mss_dataserver.')
    parser_run.set_defaults(func = start_server)

    # The create_db parser.
    parser_create_db = subparsers.add_parser('create_db', help = 'Create the database tables.')
    parser_create_db.set_defaults(func = create_db)

    # The load_geometry parser.
    parser_load_geometry = subparsers.add_parser('load_geometry', help = 'Load the geometry inventory from an XML file into the database..')
    parser_load_geometry.set_defaults(func = load_geometry)
    args = parser.parse_args()

    config = load_configuration(args.config)
    logging.basicConfig(level = config['log']['loglevel'],
                        format = "LOG - %(asctime)s - %(process)d - %(levelname)s - %(name)s: %(message)s")

    project = mss_dataserver.core.project.Project(**config)
    logging.info(project)

    args.func(project)
